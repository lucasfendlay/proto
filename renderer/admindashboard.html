<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard</title>
    <link rel="stylesheet" href="styles.css">
    <script src="userInfo.js"></script>

    <style>
        td[onclick] {
            color: blue;
            cursor: pointer;
            text-decoration: underline;
        }
    </style>


    <!-- Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
</head>
<body>
    <h1>Admin Dashboard</h1>

    <div class="container">

        <button onclick="window.location.href='home.html'">Home</button>
        <button onclick="window.location.href='directory.html'">Directory</button>
        </div>

    <!-- Filters Section -->
    <div id="filters">
        <label for="userSelect">Select User:</label>
        <select id="userSelect">
            <option value="">All Users</option>
            <!-- Dynamically populate user options -->
        </select>

        <label for="startDate">Start Date:</label>
        <input type="text" id="startDate" placeholder="Select Start Date">

        <label for="endDate">End Date:</label>
        <input type="text" id="endDate" placeholder="Select End Date">

        <button id="generateReportButton">Generate Report</button>
    </div>

    <!-- Add the button and the section to display the checked-out clients -->
<div id="checkedOutClientsSection">
    <button id="viewCheckedOutClientsButton">View All Checked-Out Profiles</button>
    <div id="checkedOutClientsList" style="display: none;">
        <h2>Checked-Out Profiles</h2>
        <ul id="checkedOutClients"></ul>
    </div>
</div>

<script>
document.getElementById('viewCheckedOutClientsButton').addEventListener('click', async () => {
    try {
        // Fetch all clients
        const response = await fetch('/get-all-clients');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const { clients } = await response.json();

        // Filter clients with checkedOut status: true
        const checkedOutClients = clients.flatMap(client => 
            client.checkedOut?.filter(item => item.status === true).map(item => ({
                clientName: client.name,
                clientId: client.id,
                checkedOutBy: item.user
            })) || [] // If checkedOut is undefined, return an empty array
        );

        // Populate the list
        const checkedOutClientsList = document.getElementById('checkedOutClients');
        checkedOutClientsList.innerHTML = ''; // Clear existing list

        checkedOutClients.forEach(async (client) => {
    try {
        console.log('Fetching details for client ID:', client.clientId);

        // Use the /get-client/:clientId endpoint
        const response = await fetch(`/get-client/${client.clientId}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch client details for ID: ${client.clientId}`);
        }
        const clientDetails = await response.json();

        // Populate the list item with fetched details
        const li = document.createElement('li');
        li.innerHTML = `
            <a href="profileview.html?id=${client.clientId}">
                <strong>Profile: ${client.clientId}</strong> | 
                Name: ${clientDetails.firstName?.toUpperCase() || 'N/A'} ${clientDetails.lastName?.toUpperCase() || 'N/A'} | 
                Phone: ${clientDetails.phoneNumber || 'N/A'} | 
                Checked out by: ${client.checkedOutBy || 'Unknown User'}
            </a>`;
        checkedOutClientsList.appendChild(li);
    } catch (error) {
        console.error(`Error fetching details for client ID ${client.clientId}:`, error);
    }
});

        // Show the list section
        document.getElementById('checkedOutClientsList').style.display = 'block';
    } catch (error) {
        console.error('Error fetching checked-out clients:', error);
    }
});
</script>

<!-- Report Section -->
<div id="report" style="display: none;">
    <h2>Report</h2>
    <table id="reportTable" border="1">
        <thead>
            <tr>
                <th>User</th>
                <th>Calls Logged</th>
                <th>Screenings Initated</th>
                <th>PACE Applications Completed</th>
                <th>PTRR Applications Completed</th>
                <th>LIS Applications Completed</th>
                <th>MSP Applications Completed</th>
                <th>SNAP Applications Completed</th>
                <th>LIHEAP Applications Completed</th>
            </tr>
        </thead>
        <tbody>
            <!-- Dynamically populate report rows -->
        </tbody>
    </table>
</div>

    <!-- Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <script>
        // Initialize Flatpickr for date inputs
        flatpickr("#startDate", {
            dateFormat: "Y-m-d",
            altInput: true,
            altFormat: "F j, Y",
        });

        flatpickr("#endDate", {
            dateFormat: "Y-m-d",
            altInput: true,
            altFormat: "F j, Y",
        });

        // Fetch users and populate the user dropdown
        async function populateUserDropdown() {
            try {
                const response = await fetch('/get-users');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const users = await response.json();
                const userSelect = document.getElementById('userSelect');
                users.forEach(user => {
                    const option = document.createElement('option');
                    option.value = user.username;
                    option.textContent = user.username;
                    userSelect.appendChild(option);
                });
            } catch (error) {
                console.error('Error fetching users:', error);
            }
        }

        // Call the function to populate the dropdown on page load
        populateUserDropdown();

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('generateReportButton').addEventListener('click', generateReport);
        });

        async function generateReport() {
    const user = document.getElementById('userSelect').value;
    const startDate = new Date(document.getElementById('startDate').value);
    const endDate = new Date(document.getElementById('endDate').value);

    try {
        // Fetch all clients
        const response = await fetch('/get-all-clients');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const { clients } = await response.json();

        // Fetch all users
        const usersResponse = await fetch('/get-users');
        if (!usersResponse.ok) {
            throw new Error(`HTTP error! status: ${usersResponse.status}`);
        }
        const users = await usersResponse.json();

        // Filter and process data
        const report = [];

        clients.forEach(client => {
            if (client.callLogs) {
                client.callLogs.forEach(log => {
                    const logDate = new Date(log.timestamp);

                    // Check if the log matches the selected user and date range
                    if ((!user || log.agent === user) && new Date(logDate.setDate(logDate.getDate() - 1)) >= startDate && logDate <= endDate) {                        
                        const agent = users.find(u => u.username === log.agent)?.username || 'Unknown User';

                        // Check if the user already exists in the report
                        let existingUser = report.find(row => row.user === agent);
                        if (!existingUser) {
                            // Add a new user entry
                            existingUser = {
                                user: agent,
                                callsLogged: 0,
                                screeningsStarted: 0,
                                paceApplicationsCompleted: 0,
                                ptrrApplicationsCompleted: 0,
                                lisApplicationsCompleted: 0,
                                mspApplicationsCompleted: 0,
                                snapApplicationsCompleted: 0,
                                liheapApplicationsCompleted: 0,
                            };
                            report.push(existingUser);
                        }

                        // Increment calls logged for each log entry
                        existingUser.callsLogged += 1;

                        // Increment other metrics cumulatively
                        existingUser.screeningsStarted += client.notes.filter(note =>
                            note.text.includes('New screening initiated.')
                        ).length;

                        existingUser.paceApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('PACE Application completed.')
                        ).length;

                        existingUser.ptrrApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('PTRR Application completed.')
                        ).length;

                        existingUser.lisApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('LIS Application completed.')
                        ).length;

                        existingUser.mspApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('MSP Application completed.')
                        ).length;

                        existingUser.snapApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('SNAP Application completed.')
                        ).length;

                        existingUser.liheapApplicationsCompleted += client.notes.filter(note =>
                            note.text.includes('LIHEAP Application completed.')
                        ).length;
                    }
                });
            }
        });

        // Render the report in the table
        const tableBody = document.querySelector('#reportTable tbody');
        tableBody.innerHTML = ''; // Clear existing rows

        report.forEach(row => {
    const startDate = document.getElementById('startDate').value; // Get start date
    const endDate = document.getElementById('endDate').value;     // Get end date

    const tr = document.createElement('tr');
    tr.innerHTML = `
        <td>${row.user}</td>
        <td onclick="redirectToUserProfiles('callsLogged', '${row.user}', '${startDate}', '${endDate}')">${row.callsLogged}</td>
        <td onclick="redirectToUserProfiles('screeningsStarted', '${row.user}', '${startDate}', '${endDate}')">${row.screeningsStarted}</td>
        <td onclick="redirectToUserProfiles('paceApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.paceApplicationsCompleted}</td>
        <td onclick="redirectToUserProfiles('ptrrApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.ptrrApplicationsCompleted}</td>
        <td onclick="redirectToUserProfiles('lisApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.lisApplicationsCompleted}</td>
        <td onclick="redirectToUserProfiles('mspApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.mspApplicationsCompleted}</td>
        <td onclick="redirectToUserProfiles('snapApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.snapApplicationsCompleted}</td>
        <td onclick="redirectToUserProfiles('liheapApplicationsCompleted', '${row.user}', '${startDate}', '${endDate}')">${row.liheapApplicationsCompleted}</td>
    `;
    tableBody.appendChild(tr);
});

        // Make the report section visible
        document.getElementById('report').style.display = 'block';

        console.log('Generated Report:', report);
    } catch (error) {
        console.error('Error generating report:', error);
    }
}

function redirectToUserProfiles(metric, user, startDate, endDate) {
    const url = `userprofiles.html?metric=${metric}&user=${encodeURIComponent(user)}&startDate=${encodeURIComponent(startDate)}&endDate=${encodeURIComponent(endDate)}`;
    window.location.href = url;
}


    </script>
</body>
</html>